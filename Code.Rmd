
---
title: "GCO Crop Pathogens"
author: "JD Stewart (@thecrobe)"
output:
  html_document: default
  pdf_document: default
editor_options:
  chunk_output_type: inline
---
# The goal of this study is to answer:

"Are crop yields greater inside or outside the crop's geographic center of origin as a function of escaping pest and pathogen pressure?"

# Reproducibility

This document can be regenerated using Rmarkdown and the associated R-script (Analyses_Figures.R). This R-script, in combination with the supplementary data files (available online at github.com/thecrobe) also allows for full reproducibility of all the the figures and analyses conducted in R. All other analyses are conducted in ArcMap by ESRI. 

## Focal Crops (n=12) Barley, Cassava, Groundnuts, Maize, Millet, Rapeseed, Rice, Rye, Sorghum, Soybean, Sunflower, Wheat
  
## Data Sources:
### Crop Yields:
Resolution: Five minute by five minute (~10km x 10km at equator)) 
  
Data is extracted from EarthStat for average yields per hectare from 1997-2003 as raster images and then the mean value per country is then calculated using zonal statistics. Data is derived from United Nations Food and Agriculture Organization (FAO), the International Food Policy Research Institute (IFPRI), the Center for Sustainability and the Global Environment (SAGE). When subnational statistics were unavailable, national figures from the Food and Agriculture Organization’s statistical database were used. List of all sources is available on EarthStat 


### Inputs

Fertilizer 
Resolution: Five minute by five minute (~10km x 10km at equator)) 
  
List of all sources is available on EarthStat.A major source of data was the fifth edition of “Fertilizer Use by Crop” (the FUBC5 dataset), a joint publication from the International Fertilizer Industry Association (IFA), the International Fertilizer Development Center (IFDC), the International Potash Institute (IPI), the Phosphate and Potash Institute (PPI), and the Food and Agriculture Organization of the United Nations (FAO). 

The publication contains national-level application rate data by crop for 42 countries, compiled from the following data sources: FAO questionnaires given to member countries; IFA questionnaires given to industry companies, research institutes, and fertilizer associations; IFDC questionnaires sent to experts attending courses, seminars, and professional meetings; and IPI and PPI communications with experts. Most of the application rate data from the FUBC5 dataset are for the years 1999 or 2000, but data for some countries are as old as 1994 and as recent as 2001. 

## Drivers to test
  
### Climate: 
Resolution: ~4-km (1/24th degree) spatial resolution averaged across 1997-2003. 
TerraClimate uses climatically aided interpolation, combining high-spatial resolution climatological normals from the WorldClim dataset, with coarser spatial resolution, but time-varying data from CRU Ts4.0 and the Japanese 55-year Reanalysis (JRA55). 

#### Pests: 
Resolution: Resolution: Country level. Mean from 1997-2003 derived from FAO

### GDP: 
Resolution: Country level. Mean from 1997-2003 derived from WorldBank

## Geographic Centers of Origin: 
###These are defined at the country level for each crop with regions being taken from FAOSTAT labels and publications of origins from a mixture of molecular and archaeological studies.
  
### Near East
  * Barley
  * Wheat
    
### South America
  * Cassava
  * Groundnuts

### Central America 
  * Maize
    
### China + SE Asia + India
  * Rice
  
### China
  * Soybean
  * Millet
  
### North America 
  * Sunflower

### North East Africa
  * Sorghum

### Central Asia, Turkey, Transcaucasia,and Iran  
  * Rye
  
### Central Europe 
  * Rapeseed
  

```{r, Packages, include=TRUE, echo=FALSE, message=FALSE, eval=TRUE, warning=FALSE}

#models
library(wPerm)
library(caret)
library(spatialEco)
library(rgdal)
library(wPerm)
library(RVAideMemoire)

#plots
library(RColorBrewer)
library(ggplot2)
library(wesanderson)

#data wrangling
library(reshape2)
library(dplyr)
library(Hmisc)
```

## Yields Inside and Outside GCO 

<div class = "col-md-4">
<br><br> **What Was Tested:** Do crop yields vary inside and outside GCO?
</div>

<div class = "col-md-4">
<br><br> **What This Allows Me To Do:** Identify the distribution of yields inside and outside GCO and if they statistically differ 
</div>

<div class = "col-md-4">
<br><br> **What Are The Model Assumptions:** Permutations T-Tests were used to test if there is a significant difference in the means of each crop separated by inside/outside GCO. These tests were chosen as they have few assumptions about the distribution and independence of the data (i.e. exchangability is th only assumption however there is no way to test for this as we do not know the true distribution). Likewise permutational tests destroy the spatial-autocorrelation structure that influences test results. Plots are solely visual.
</div>

<div class = "col-md-12">
<br><br> **What Are The Model Assumptions:** Permutations T-Tests were used to test if there is a significant difference in the means of each crop separated by inside/outside GCO. These tests were chosen as they have few assumptions about the distribution and independence of the data (i.e. exchangability is th only assumption however there is no way to test for this as we do not know the true distribution). Likewise permutational tests destroy the spatial-autocorrelation structure that influences test results. Plots are solely visual.
</div>

```{r, Merge Mapping,echo=FALSE}
mapping<-read.csv("Fishnets/mapping_GCOfishnet.csv", header=T, fileEncoding = "UTF-8-BOM")
yield<-read.csv("Fishnets/yield_fishnet.csv", header=T)
yield.mapping<-merge(yield,mapping, by="Fishnet_ID")
```



## Barley 
```{r,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Barley yield with individual colors", cache=TRUE}
barley<-na.omit(yield.mapping %>% dplyr::select(barley_HgHa,barley_GCO))

#Outlier removal
hist(barley$barley_HgHa)
qqnorm(barley$barley_HgHa)
barley.filter<-barley %>% filter(between(barley_HgHa, quantile(barley_HgHa, .01), quantile(barley_HgHa, .99))) #remove top and bottom 1% 
hist(barley.filter$barley_HgHa)
qqnorm(barley.filter$barley_HgHa)
dim(barley) - dim(barley.filter) # Num Outliers Removed
summary(barley.filter)
barley<-barley.filter

#Inside vs Outside GCO 
barley.inside<-filter(barley, barley_GCO == "Inside")
barley.outside<-filter(barley, barley_GCO == "Outside")
barley.m<-melt(barley)
summary(barley.inside)
summary(barley.outside)

#Plot
ggplot(barley.m, aes(x=barley.m$barley_GCO, y=barley.m$value, color=barley.m$barley_GCO)) + 
  geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
set.seed(8675309)
barley.perm<-perm.t.test(barley.inside$barley_HgHa,barley.outside$barley_HgHa,progress=FALSE)
print(barley.perm)
```

## Cassava 
```{r,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Cassava yield with individual colors,", cache=TRUE}
cassava<-na.omit(yield.mapping %>% dplyr::select(cassava_HgHa,cassava_GCO))

#Outlier removal
hist(cassava$cassava_HgHa)
qqnorm(cassava$cassava_HgHa)
cassava.filter<-cassava %>% filter(between(cassava_HgHa, quantile(cassava_HgHa, .01), quantile(cassava_HgHa, .99))) #remove top and bottom 1% 
hist(cassava.filter$cassava_HgHa)
qqnorm(cassava.filter$cassava_HgHa)
dim(cassava) - dim(cassava.filter) # Num Outliers Removed
summary(cassava.filter)
cassava<-cassava.filter

#Inside vs Outside GCO 
cassava.inside<-filter(cassava, cassava_GCO == "Inside")
cassava.outside<-filter(cassava, cassava_GCO == "Outside")
cassava.m<-melt(cassava)
summary(cassava.inside)
summary(cassava.outside)

#Plot
ggplot(cassava.m, aes(x=cassava.m$cassava_GCO, y=cassava.m$value, color=cassava.m$cassava_GCO)) + 
  geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
set.seed(8675309)
cassava.perm<-perm.t.test(cassava.inside$cassava_HgHa,cassava.outside$cassava_HgHa,progress=FALSE)
print(cassava.perm)
```
## Groundnut 
```{r,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Groundnut yield with individual colors", cache=TRUE}
groundnut<-na.omit(yield.mapping %>% dplyr::select(groundnut_HgHa,groundnut_GCO))

#Outlier removal
hist(groundnut$groundnut_HgHa)
qqnorm(groundnut$groundnut_HgHa)
groundnut.filter<-groundnut %>% filter(between(groundnut_HgHa, quantile(groundnut_HgHa, .01), quantile(groundnut_HgHa, .99))) #remove top and bottom 1% 
hist(groundnut.filter$groundnut_HgHa)
qqnorm(groundnut.filter$groundnut_HgHa)
dim(groundnut) - dim(groundnut.filter) # Num Outliers Removed
summary(groundnut.filter)
groundnut<-groundnut.filter

#Inside vs Outside GCO 
groundnut.inside<-filter(groundnut, groundnut_GCO == "Inside")
groundnut.outside<-filter(groundnut, groundnut_GCO == "Outside")
groundnut.m<-melt(groundnut)
summary(groundnut.inside)
summary(groundnut.outside)

#Plot
ggplot(groundnut.m, aes(x=groundnut.m$groundnut_GCO, y=groundnut.m$value, color=groundnut.m$groundnut_GCO)) + 
 geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
set.seed(8675309)
groundnut.perm<-perm.t.test(groundnut.inside$groundnut_HgHa,groundnut.outside$groundnut_HgHa, progress=FALSE)
print(groundnut.perm)

```
## Maize 
```{r,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Maize yield with individual colors", cache=TRUE}
maize<-na.omit(yield.mapping %>% dplyr::select(maize_HgHa,maize_GCO))

#Outlier removal
hist(maize$maize_HgHa)
qqnorm(maize$maize_HgHa)
maize.filter<-maize %>% filter(between(maize_HgHa, quantile(maize_HgHa, .01), quantile(maize_HgHa, .99))) #remove top and bottom 1% 
hist(maize.filter$maize_HgHa)
qqnorm(maize.filter$maize_HgHa)
dim(maize) - dim(maize.filter) # Num Outliers Removed
summary(maize.filter)
maize<-maize.filter

#Inside vs Outside GCO 
maize.inside<-filter(maize, maize_GCO == "Inside")
maize.outside<-filter(maize, maize_GCO == "Outside")
maize.m<-melt(maize)
summary(maize.inside)
summary(maize.outside)

#Plot
ggplot(maize.m, aes(x=maize.m$maize_GCO, y=maize.m$value, color=maize.m$maize_GCO)) + 
 geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
set.seed(8675309)
maize.perm<-perm.t.test(maize.inside$maize_HgHa,maize.outside$maize_HgHa, progress=FALSE)
print(maize.perm)

```
## Millet 
```{r,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Millet yield with individual colors", cache=TRUE}
millet<-na.omit(yield.mapping %>% dplyr::select(millet_HgHa,millet_GCO))

#Outlier removal
hist(millet$millet_HgHa)
qqnorm(millet$millet_HgHa)
millet.filter<-millet %>% filter(between(millet_HgHa, quantile(millet_HgHa, .01), quantile(millet_HgHa, .99))) #remove top and bottom 1% 
hist(millet.filter$millet_HgHa)
qqnorm(millet.filter$millet_HgHa)
dim(millet) - dim(millet.filter) # Num Outliers Removed
summary(millet.filter)
millet<-millet.filter

#Inside vs Outside GCO 
millet.inside<-filter(millet, millet_GCO == "Inside")
millet.outside<-filter(millet, millet_GCO == "Outside")
millet.m<-melt(millet)
summary(millet.inside)
summary(millet.outside)

#Plot
ggplot(millet.m, aes(x=millet.m$millet_GCO, y=millet.m$value, color=millet.m$millet_GCO)) +   
  geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
set.seed(8675309)
millet.perm<-perm.t.test(millet.inside$millet_HgHa,millet.outside$millet_HgHa, progress=FALSE)
print(millet.perm)
```
## Rapeseed 
```{r,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Rapeseed yield with individual colors", cache=TRUE}
rapeseed<-na.omit(yield.mapping %>% dplyr::select(rapeseed_HgHa,rapeseed_GCO))

#Outlier removal
hist(rapeseed$rapeseed_HgHa)
qqnorm(rapeseed$rapeseed_HgHa)
rapeseed.filter<-rapeseed %>% filter(between(rapeseed_HgHa, quantile(rapeseed_HgHa, .01), quantile(rapeseed_HgHa, .99))) #remove top and bottom 1% 
hist(rapeseed.filter$rapeseed_HgHa)
qqnorm(rapeseed.filter$rapeseed_HgHa)
dim(rapeseed) - dim(rapeseed.filter) # Num Outliers Removed
summary(rapeseed.filter)
rapeseed<-rapeseed.filter

#Inside vs Outside GCO 
rapeseed.inside<-filter(rapeseed, rapeseed_GCO == "Inside")
rapeseed.outside<-filter(rapeseed, rapeseed_GCO == "Outside")
rapeseed.m<-melt(rapeseed)
summary(rapeseed.inside)
summary(rapeseed.outside)

#Plot
ggplot(rapeseed.m, aes(x=rapeseed.m$rapeseed_GCO, y=rapeseed.m$value, color=rapeseed.m$rapeseed_GCO)) + 
   geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
set.seed(8675309)
rapeseed.perm<-perm.t.test(rapeseed.inside$rapeseed_HgHa,rapeseed.outside$rapeseed_HgHa, progress=FALSE)
print(rapeseed.perm)
```
## Rice 
```{r,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Rice yield with individual colors", cache=TRUE}
rice<-na.omit(yield.mapping %>% dplyr::select(rice_HgHa,rice_GCO))

#Outlier removal
hist(rice$rice_HgHa)
qqnorm(rice$rice_HgHa)
rice.filter<-rice %>% filter(between(rice_HgHa, quantile(rice_HgHa, .01), quantile(rice_HgHa, .99))) #remove top and bottom 1% 
hist(rice.filter$rice_HgHa)
qqnorm(rice.filter$rice_HgHa)
dim(rice) - dim(rice.filter) # Num Outliers Removed
summary(rice.filter)
rice<-rice.filter

#Filter
rice.inside<-filter(rice, rice_GCO == "Inside")
rice.outside<-filter(rice, rice_GCO == "Outside")
rice.m<-melt(rice)
summary(rice.inside)
summary(rice.outside)

#Plot
ggplot(rice.m, aes(x=rice.m$rice_GCO, y=rice.m$value, color=rice.m$rice_GCO)) +   geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
set.seed(8675309)
rice.perm<-perm.t.test(rice.inside$rice_HgHa,rice.outside$rice_HgHa, progress=FALSE)
print(rice.perm)
```
## Rye 
```{r,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Rye yield with individual colors", cache=TRUE}
rye<-na.omit(yield.mapping %>% dplyr::select(rye_HgHa,rye_GCO))

#Outlier removal
hist(rye$rye_HgHa)
qqnorm(rye$rye_HgHa)
rye.filter<-rye %>% filter(between(rye_HgHa, quantile(rye_HgHa, .01), quantile(rye_HgHa, .99))) #remove top and bottom 1% 
hist(rye.filter$rye_HgHa)
qqnorm(rye.filter$rye_HgHa)
dim(rye) - dim(rye.filter) # Num Outliers Removed
summary(rye.filter)
rye<-rye.filter

#Inside vs Outside GCO 
rye.inside<-filter(rye, rye_GCO == "Inside")
rye.outside<-filter(rye, rye_GCO == "Outside")
rye.m<-melt(rye)
summary(rye.inside)
summary(rye.outside)

#Plot
ggplot(rye.m, aes(x=rye.m$rye_GCO, y=rye.m$value, color=rye.m$rye_GCO)) + 
  geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
set.seed(8675309)
rye.perm<-perm.t.test(rye.inside$rye_HgHa,rye.outside$rye_HgHa,progress=FALSE)
print(rye.perm)
```
## Sorghum 
```{r,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Sorghum yield with individual colors", cache=TRUE}

sorghum<-na.omit(yield.mapping %>% dplyr::select(sorghum_HgHa,sorghum_GCO))

#Outlier Removal
hist(sorghum$sorghum_HgHa)
qqnorm(sorghum$sorghum_HgHa)
sorghum.filter<-sorghum %>% filter(between(sorghum_HgHa, quantile(sorghum_HgHa, .01), quantile(sorghum_HgHa, .99))) #remove top and bottom 1% 
hist(sorghum.filter$sorghum_HgHa)
qqnorm(sorghum.filter$sorghum_HgHa)
dim(sorghum) - dim(sorghum.filter) # Num Outliers Removed
summary(sorghum)
summary(sorghum.filter)
sorghum<-sorghum.filter

#Inside vs Outside GCO 
sorghum.inside<-filter(sorghum, sorghum_GCO == "Inside")
sorghum.outside<-filter(sorghum, sorghum_GCO == "Outside")
sorghum.m<-melt(sorghum)
summary(sorghum.inside)
summary(sorghum.outside)

#Plot
ggplot(sorghum.m, aes(x=sorghum.m$sorghum_GCO, y=sorghum.m$value, color=sorghum.m$sorghum_GCO)) + 
  geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
set.seed(8675309)
sorghum.perm<-perm.t.test(sorghum.inside$sorghum_HgHa,sorghum.outside$sorghum_HgHa, progress=FALSE)
print(sorghum.perm)
```
## Soybean 
```{r,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Soybean yield with individual colors", cache=TRUE}
soybean<-na.omit(yield.mapping %>% dplyr::select(soybean_HgHa,soybean_GCO))

#Outlier Removal
hist(soybean$soybean_HgHa)
qqnorm(soybean$soybean_HgHa)
soybean.filter<-soybean %>% filter(between(soybean_HgHa, quantile(soybean_HgHa, .01), quantile(soybean_HgHa, .99))) #remove top and bottom 1% 
hist(soybean.filter$soybean_HgHa)
qqnorm(soybean.filter$soybean_HgHa)
dim(soybean) - dim(soybean.filter) # Num Outliers Removed
summary(soybean)
summary(soybean.filter)
soybean<-soybean.filter


#Inside vs Outside GCO 
soybean.inside<-filter(soybean, soybean_GCO == "Inside")
soybean.outside<-filter(soybean, soybean_GCO == "Outside")
soybean.m<-melt(soybean)
summary(soybean.inside)
summary(soybean.outside)

#Plot
ggplot(soybean.m, aes(x=soybean.m$soybean_GCO, y=soybean.m$value, color=soybean.m$soybean_GCO)) + 
 geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
set.seed(8675309)
soybean.perm<-perm.t.test(soybean.inside$soybean_HgHa,soybean.outside$soybean_HgHa, progress=FALSE)
print(soybean.perm)
```
## Sunflower 
```{r,fig.align='center',message=FALSE,warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Sunflower yield with individual colors", cache=TRUE}
sunflower<-na.omit(yield.mapping %>% dplyr::select(sunflower_HgHa,sunflower_GCO))

#Outlier Removal
hist(sunflower$sunflower_HgHa)
qqnorm(sunflower$sunflower_HgHa)
sunflower.filter<-sunflower %>% filter(between(sunflower_HgHa, quantile(sunflower_HgHa, .01), quantile(sunflower_HgHa, .99))) #remove top and bottom 1% 
hist(sunflower.filter$sunflower_HgHa)
qqnorm(sunflower.filter$sunflower_HgHa)
dim(sunflower) - dim(sunflower.filter) # Num Outliers Removed
summary(sunflower)
summary(sunflower.filter)
sunflower<-sunflower.filter

#Inside vs Outside GCO 
sunflower.inside<-filter(sunflower, sunflower_GCO == "Inside")
sunflower.outside<-filter(sunflower, sunflower_GCO == "Outside")
sunflower.m<-melt(sunflower)
summary(sunflower.inside)
summary(sunflower.outside)

#Plot
ggplot(sunflower.m, aes(x=sunflower.m$sunflower_GCO, y=sunflower.m$value, color=sunflower.m$sunflower_GCO)) + 
  geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
sunflower.perm<-perm.t.test(sunflower.inside$sunflower_HgHa,sunflower.outside$sunflower_HgHa, progress=FALSE)
print(sunflower.perm)
```
## Wheat 
```{r,fig.align='center',message=FALSE, warning=FALSE,fig.cap="Jittered Boxplot with mean and interquartile range shown of Wheat yield with individual colors", cache=TRUE}
wheat<-na.omit(yield.mapping %>% dplyr::select(wheat_HgHa,wheat_GCO))

#Outlier Removal
hist(wheat$wheat_HgHa)
qqnorm(wheat$wheat_HgHa)
wheat.filter<-wheat %>% filter(between(wheat_HgHa, quantile(wheat_HgHa, .01), quantile(wheat_HgHa, .99))) #remove top and bottom 1% 
hist(wheat.filter$wheat_HgHa)
qqnorm(wheat.filter$wheat_HgHa)
dim(wheat) - dim(wheat.filter) # Num Outliers Removed
summary(wheat)
summary(wheat.filter)
wheat<-wheat.filter

#Inside vs Outside GCO 
wheat.inside<-filter(wheat, wheat_GCO == "Inside")
wheat.outside<-filter(wheat, wheat_GCO == "Outside")
wheat.m<-melt(wheat)
summary(wheat.inside)
summary(wheat.outside)

#Plot
ggplot(wheat.m, aes(x=wheat.m$wheat_GCO, y=wheat.m$value, color=wheat.m$wheat_GCO)) + 
  geom_jitter(alpha=0.4, width=0.2) + 
  geom_boxplot(color="black", fill="transparent", width=0.4)+
  scale_color_manual(values = wes_palette("Darjeeling1",type = "discrete")) + 
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Yield (Hg/Ha)") +xlab("") + labs(color='GCO') 

# Permutational T Test
wheat.perm<-perm.t.test(wheat.inside$wheat_HgHa,wheat.outside$wheat_HgHa, progress=FALSE)
print(wheat.perm)
```

## Near Analysis 

<div class = "col-md-4">
<br><br> **What Was Tested:** Does a distance decay relationship exist for each crop as you increase distance from GCO? If this is true, what is the magnitude and direction? 
</div>

<div class = "col-md-4">
<br><br> **What This Allows Me To Do:** Identify if crop yields are greater as a fucntion of distance from GCO
</div>

<div class = "col-md-4">
<br><br> **What Are The Model Assumptions:**For generating the near table (a table of the distance centroid of each pixel outside of the GCO and crop yield) a geodesic approach was used to be more accurate at the equator and the poles. Likewise, permutational Spearman correlations are used and are non-parametric (rank ordered) and permutational. The nature of permutation means that the spatio-temporal autocorrelative structure in the data is removed. 
</div>

```{r message=TRUE, warning=FALSE, cache=TRUE}
### Barley ###
barley.near<-read.csv(file = "Near_Coded/Barley_Near.csv", header=T)

#Outlier Removal
barley.filter<-barley.near %>% filter(between(mean_barle, quantile(mean_barle, .01), quantile(mean_barle, .99))) #remove top and bottom 1% 
barley.near<-barley.filter

#Permutational  Correlation
near.barley<-perm.relation(x = log10(barley.near$NEAR_DIST),barley.near$mean_barle,method = "pearson")
print(near.barley$Observed) #coefficient
print(near.barley$P.value) # p-value
#Plot
ggplot(barley.near, aes(x=log10(NEAR_DIST), y=log10(barley.near$mean_barle))) +
  geom_point(alpha=0.2, color="#00A9B4") + geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')


### Cassava ###
cassava.near<-read.csv(file = "Near_Coded/Cassava_Near.csv", header=T)

#Outlier Removal
cassava.filter<-cassava.near %>% filter(between(mean_cassa, quantile(mean_cassa, .01), quantile(mean_cassa, .99))) #remove top and bottom 1% 
cassava.near<-cassava.filter

#Permutational  Correlartion
near.cassava<-perm.relation(x = log10(cassava.near$NEAR_DIST),cassava.near$mean_cassa,method = "pearson")
print(near.cassava$Observed) #coefficient
print(near.cassava$P.value) # p-value
#Plot
ggplot(cassava.near, aes(x=log10(NEAR_DIST), y=log10(cassava.near$mean_cassa))) +
  geom_point(alpha=0.2, color="#00A9B4") + geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')


### Groundnut ###
groundnut.near<-read.csv(file = "Near_Coded/Groundnut_Near.csv", header=T)

#Outlier Removal
groundnut.filter<-groundnut.near %>% filter(between(mean_groun, quantile(mean_groun, .01), quantile(mean_groun, .99))) #remove top and bottom 1% 
groundnut.near<-groundnut.filter

#Permutational  Correlartion
near.groundnut<-perm.relation(x = log10(groundnut.near$NEAR_DIST),groundnut.near$mean_groun,method = "pearson")
print(near.groundnut$Observed) #coefficient
print(near.groundnut$P.value) # p-value
#Plot
ggplot(groundnut.near, aes(x=log10(NEAR_DIST), y=log10(groundnut.near$mean_groun))) +
  geom_point(alpha=0.2, color="#00A9B4") + geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')

### Maize ###
maize.near<-read.csv(file = "Near_Coded/Maize_Near.csv", header=T)

#Outlier Removal
maize.filter<-maize.near %>% filter(between(mean_maize, quantile(mean_maize, .01), quantile(mean_maize, .99))) #remove top and bottom 1% 
maize.near<-maize.filter

#Permutational  Correlation
near.maize<-perm.relation(x = log10(maize.near$NEAR_DIST),maize.near$mean_maize,method = "pearson")
print(near.maize$Observed) #coefficient
print(near.maize$P.value) # p-value
#Plot
ggplot(maize.near, aes(x=log10(NEAR_DIST), y=log10(maize.near$mean_maize))) +
  geom_point(alpha=0.2, color="#F0AB00") +geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')

### Millet ###
millet.near<-read.csv(file = "Near_Coded/Millet_Near.csv", header=T)

#Outlier Removal
millet.filter<-millet.near %>% filter(between(mean_mille, quantile(mean_mille, .01), quantile(mean_mille, .99))) #remove top and bottom 1% 
millet.near<-millet.filter

#Permutational  Correlation
near.millet<-perm.relation(x = log10(millet.near$NEAR_DIST),millet.near$mean_mille,method = "pearson")
print(near.millet$Observed) #coefficient
print(near.millet$P.value) # p-value
#Plot
ggplot(millet.near, aes(x=log10(NEAR_DIST), y=log10(millet.near$mean_mille))) +
  geom_point(alpha=0.2, color="#00A9B4") + geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')


### Rapeseed ###
rapeseed.near<-read.csv(file = "Near_Coded/Rapeseed_Near.csv", header=T)

#Outlier Removal
rapeseed.filter<-rapeseed.near %>% filter(between(mean_rapes, quantile(mean_rapes, .01), quantile(mean_rapes, .99))) #remove top and bottom 1% 
rapeseed.near<-rapeseed.filter

#Permutational  Correlartion
near.rapeseed<-perm.relation(x = log10(rapeseed.near$NEAR_DIST),rapeseed.near$mean_rapes,method = "pearson")
print(near.rapeseed$Observed) #coefficient
print(near.rapeseed$P.value) # p-value
#Plot
ggplot(rapeseed.near, aes(x=log10(NEAR_DIST), y=log10(rapeseed.near$mean_rapes))) +
  geom_point(alpha=0.2, color="#38474E") + geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')

### Rice ###
rice.near<-read.csv(file = "Near_Coded/Rice_Near.csv", header=T)

#Outlier Removal
rice.filter<-rice.near %>% filter(between(mean_rice, quantile(mean_rice, .01), quantile(mean_rice, .99))) #remove top and bottom 1% 
rice.near<-rice.filter
#Permutational  Correlation

near.rice<-perm.relation(x = log10(rice.near$NEAR_DIST),rice.near$mean_rice,method = "pearson")
print(near.rice$Observed) #coefficient
print(near.rice$P.value) # p-value
#Plot
ggplot(rice.near, aes(x=log10(NEAR_DIST), y=log10(rice.near$mean_rice))) +
  geom_point(alpha=0.2, color="#FBA900") + geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')

### Rye ###
rye.near<-read.csv(file = "Near_Coded/Rye_Near.csv", header=T)

#Outlier Removal
rye.filter<-rye.near %>% filter(between(mean_rye_Y, quantile(mean_rye_Y, .01), quantile(mean_rye_Y, .99))) #remove top and bottom 1% 
rye.near<-rye.filter

#Permutational  Correlation
near.rye<-perm.relation(x = log10(rye.near$NEAR_DIST),rye.near$mean_rye_Y,method = "pearson")
print(near.rye$Observed) #coefficient
print(near.rye$P.value) # p-value
#Plot
ggplot(rye.near, aes(x=log10(NEAR_DIST), y=log10(rye.near$mean_rye_Y))) +
  geom_point(alpha=0.2, color="#FFB200") +geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')

### Sorghum ###
sorghum.near<-read.csv(file = "Near_Coded/Sorghum_near.csv", header=T)

#Outlier Removal
sorghum.filter<-sorghum.near %>% filter(between(mean_sorgh, quantile(mean_sorgh, .01), quantile(mean_sorgh, .99))) #remove top and bottom 1% 
sorghum.near<-sorghum.filter

#Permutational  Correlartion
near.sorghum<-perm.relation(x = log10(sorghum.near$NEAR_DIST),sorghum.near$mean_sorgh,method = "pearson")
print(near.sorghum$Observed) #coefficient
print(near.sorghum$P.value) # p-value

#Plot
ggplot(sorghum.near, aes(x=log10(NEAR_DIST), y=log10(sorghum.near$mean_sorgh))) +
     geom_point(alpha=0.2, color="#00A9B4") +geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')

### Soybean ###
soybean.near<-read.csv(file = "Near_Coded/Soybean_Near.csv", header=T)

#Outlier Removal
soybean.filter<-soybean.near %>% filter(between(mean_soybe, quantile(mean_soybe, .01), quantile(mean_soybe, .99))) #remove top and bottom 1% 
soybean.near<-soybean.filter

#Permutational  Correlation
near.soybean<-perm.relation(x = log10(soybean.near$NEAR_DIST),soybean.near$mean_soybe,method = "pearson")
print(near.soybean$Observed) #coefficient
print(near.soybean$P.value) # p-value
#Plot
ggplot(soybean.near, aes(x=log10(NEAR_DIST), y=log10(soybean.near$mean_soybe))) +
  geom_point(alpha=0.2, color="#00A9B4") +geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')

### Sunflower ###
sunflower.near<-read.csv(file = "Near_Coded/Sunflower_Near.csv", header=T)

#Outlier Removal
sunflower.filter<-sunflower.near %>% filter(between(mean_sunfl, quantile(mean_sunfl, .01), quantile(mean_sunfl, .99))) #remove top and bottom 1% 
sunflower.near<-sunflower.filter

#Permutational Spearman Correlation
near.sunflower<-perm.relation(x = log10(sunflower.near$NEAR_DIST),sunflower.near$mean_sunfl,method = "pearson")
print(near.sunflower$Observed) #coefficient
print(near.sunflower$P.value) # p-value
#Plot
ggplot(sunflower.near, aes(x=log10(NEAR_DIST), y=log10(sunflower.near$mean_sunfl))) +
  geom_point(alpha=0.2, color="#38474E") + geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')


### Wheat ### 
wheat.near<-read.csv(file = "Near_Coded/Wheat_near.csv", header=T)

#Outlier Removal
wheat.filter<-wheat.near %>% filter(between(mean_wheat, quantile(mean_wheat, .01), quantile(mean_wheat, .99))) #remove top and bottom 1% 
wheat.near<-wheat.filter

#Permutational  Correlartion
near.wheat<-perm.relation(x = log10(wheat.near$NEAR_DIST),wheat.near$mean_wheat,method = "pearson")
print(near.wheat$Observed) #coefficient
print(near.wheat$P.value) # p-value

#Plot
ggplot(wheat.near, aes(x=log10(NEAR_DIST), y=log10(wheat.near$mean_wheat))) +
  geom_point(alpha=0.2, color="#00A9B4") + geom_smooth(method = "lm",color="#DB3500") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) + 
  ylab("Log10 Yield (Hg/Ha)") +xlab("Log 10 Distance") + labs(color='GCO')


```


## Random Forest Regression (RFR)

<div class = "col-md-4">
<br><br> **What Was Tested:** What are the drivers of variation in crop yields? 
</div>

<div class = "col-md-4">
<br><br> **What This Allows Me To Do:** Identify correlation between expected drivers are with the distributiion of global crop yields and quantify error. 
</div>

<div class = "col-md-4">
<br><br> **What Are The Model Assumptions:** The sampling is representative of the population; which is not unique and applies to all models. RFR was chosen as it has no formal distributional assumptions, random forests are non-parametric and can thus handle skewed, multimodal, and spatio-temporally autocorrelated data.
</div>

### Barley RFR 
```{r, Analysis: Barley RFR, cache=TRUE} 

rf.barley<-read.csv(file="Models/Barley_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.barley)
rf<-log10(rf+1)
summary(rf)
sapply(rf.barley, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$barley_HgHa, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.barley <- train(barley_HgHa~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.barley) #print results
#write.csv(fit.rf.barley$results, "Models/barley_rfFIT.csv")

stopCluster(cl)


barley.varIMP<-(varImp(fit.rf.barley)) #identify variable importance
plot(barley.varIMP)
#write.csv(barley.varIMP$importance, file = "Models/barley_varIMP.csv")
# Model Performance
predictions <- predict(fit.rf.barley, validation) #predict 
pred.error<-RMSE(predictions,validation$barley_HgHa) #get the Root Mean Standard Error of predicted values
exp(pred.error-1) #put in yield values

modelerror <- exp(predict(fit.rf.barley, rf )-1) #predict on whole dataset
summary(modelerror) #make sure it worked honeyyyy

#write.csv(modelerror,file="Models/Predictions/barley_predictions.csv") # export for mapping

```

### Cassava RFR
```{r, Analysis: Cassava RFR, cache=TRUE}

rf.cassava<-read.csv(file="Models/Cassava_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.cassava)
rf<-log10(rf+1)
summary(rf)
sapply(rf.cassava, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$cassava_HgHa, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.cassava <- train(cassava_HgHa~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.cassava) #print results

stopCluster(cl)

cassava.varIMP<-(varImp(fit.rf.cassava)) #identify variable importance
plot(cassava.varIMP)
#write.csv(cassava.varIMP$importance, file = "Models/cassava_varIMP.csv")
#write.csv(fit.rf.cassava$results, "Models/cassava_rfFIT.csv")


# Model Performance
predictions <- predict(fit.rf.cassava, validation) #predict 
pred.error<-RMSE(predictions,validation$cassava_HgHa) #get the Root Mean Standard Error of predicted values
exp(pred.error) #put in yield values

modelerror <- exp(predict(fit.rf.cassava, rf )-1) #predict on whole dataset
summary(modelerror) #make sure it worked honeyyyy
#write.csv(modelerror,file="Models/Predictions/cassava_predictions.csv") # export for mapping

```

### Groundnut RFR
```{r, Analysis: Groundnut RFR, cache=TRUE}

rf.groundnut<-read.csv(file="Models/Groundnut_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.groundnut)
rf<-log10(rf+1)
summary(rf)
sapply(rf.groundnut, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$groundnut_HgHa, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.groundnut <- train(groundnut_HgHa~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.groundnut) #print results
#write.csv(fit.rf.groundnut$results, "Models/groundnut_rfFIT.csv")

stopCluster(cl)

groundnut.varIMP<-(varImp(fit.rf.groundnut)) #identify variable importance
plot(groundnut.varIMP)
#write.csv(groundnut.varIMP$importance, file = "Models/groundnut_varIMP.csv")
# Model Performance
predictions <- predict(fit.rf.groundnut, validation) #predict 
pred.error<-RMSE(predictions,validation$groundnut_HgHa) #get the Root Mean Standard Error of predicted values
exp(pred.error) #put in yield values

modelerror <- exp(predict(fit.rf.groundnut, rf )-1) #predict on whole dataset
head(modelerror) #make sure it worked honeyyyy
#write.csv(modelerror,file="Models/Predictions/groundnut_predictions.csv") # export for mapping

```

### Maize RFR
```{r, Analysis: Maize RFR, cache=TRUE}

rf.maize<-read.csv(file="Models/Maize_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.maize)
rf<-log10(rf+1)
summary(rf)
sapply(rf.maize, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$maize_HgHa, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.maize <- train(maize_HgHa~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.maize) #print results
#write.csv(fit.rf.maize$results, "Models/maize_rfFIT.csv")

stopCluster(cl)

maize.varIMP<-(varImp(fit.rf.maize)) #identify variable importance
plot(maize.varIMP)
#write.csv(maize.varIMP$importance, file = "Models/maize_varIMP.csv")
# Model Performance
predictions <- predict(fit.rf.maize, validation) #predict 
pred.error<-RMSE(predictions,validation$maize_HgHa) #get the Root Mean Standard Error of predicted values
exp(pred.error) #put in yield values

modelerror <- exp(predict(fit.rf.maize, rf )-1) #predict on whole dataset
head(modelerror) #make sure it worked honeyyyy
#write.csv(modelerror,file="Models/Predictions/maize_predictions.csv") # export for mapping

```

### Millet RFR 
```{r, Analysis: Millet RFR, cache=TRUE}

rf.millet<-read.csv(file="Models/Millet_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.millet)
rf<-log10(rf+1)
summary(rf)
sapply(rf.millet, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$millet_HgHa, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.millet <- train(millet_HgHa~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.millet) #print results
#write.csv(fit.rf.millet$results, "Models/millet_rfFIT.csv")


stopCluster(cl)

millet.varIMP<-(varImp(fit.rf.millet)) #identify variable importance
plot(millet.varIMP)
#write.csv(millet.varIMP$importance, file = "Models/millet_varIMP.csv")
# Model Performance
predictions <- predict(fit.rf.millet, validation) #predict 
pred.error<-RMSE(predictions,validation$millet_HgHa) #get the Root Mean Standard Error of predicted values
exp(pred.error) #put in yield values

modelerror <- exp(predict(fit.rf.millet, rf )-1) #predict on whole dataset
head(modelerror) #make sure it worked honeyyyy
#write.csv(modelerror,file="Models/Predictions/millet_predictions.csv") # export for mapping

```

### Rapeseed RFR
```{r, Analysis: Rapeseed RFR, cache=TRUE}

rf.rapeseed<-read.csv(file="Models/Rapeseed_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.rapeseed)
rf<-log10(rf+1)
summary(rf)
sapply(rf.rapeseed, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$rapeseed_HgHa, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.rapeseed <- train(rapeseed_HgHa~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.rapeseed) #print results
#write.csv(fit.rf.rapeseed$results, "Models/rapeseed_rfFIT.csv")

stopCluster(cl)

rapeseed.varIMP<-(varImp(fit.rf.rapeseed)) #identify variable importance
plot(rapeseed.varIMP)
#write.csv(rapeseed.varIMP$importance, file = "Models/rapeseed_varIMP.csv")
# Model Performance
predictions <- predict(fit.rf.rapeseed, validation) #predict 
pred.error<-RMSE(predictions,validation$rapeseed_HgHa) #get the Root Mean Standard Error of predicted values
exp(pred.error) #put in yield values

modelerror <- exp(predict(fit.rf.rapeseed, rf )-1) #predict on whole dataset
summary(modelerror) #make sure it worked honeyyyy
#write.csv(modelerror,file="Models/Predictions/rapeseed_predictions.csv") # export for mapping

```

### Rice RFR 
```{r, Analysis: Rice RFR, cache=TRUE}

rf.rice<-read.csv(file="Models/Rice_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.rice)
rf<-log10(rf+1)
summary(rf)
sapply(rf.rice, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$rice_HgHa, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.rice <- train(rice_HgHa~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.rice) #print results
#write.csv(fit.rf.rice$results, "Models/rice_rfFIT.csv")

stopCluster(cl)

rice.varIMP<-(varImp(fit.rf.rice)) #identify variable importance
plot(rice.varIMP)
#write.csv(rice.varIMP$importance, file = "Models/rice_varIMP.csv")
# Model Performance
predictions <- predict(fit.rf.rice, validation) #predict 
pred.error<-RMSE(predictions,validation$rice_HgHa) #get the Root Mean Standard Error of predicted values
exp(pred.error) #put in yield values

modelerror <- exp(predict(fit.rf.rice, rf )-1) #predict on whole dataset
head(modelerror) #make sure it worked honeyyyy
#write.csv(modelerror,file="Models/Predictions/rice_predictions.csv") # export for mapping

```

### Rye RFR
```{r, Analysis: Rye RFR, cache=TRUE}

rf.rye<-read.csv(file="Models/Rye_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.rye)
rf<-log10(rf+1)
summary(rf)
sapply(rf.rye, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$rye_HgHa, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.rye <- train(rye_HgHa~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.rye) #print results
#write.csv(fit.rf.rye$results, "Models/rye_rfFIT.csv")


stopCluster(cl)

rye.varIMP<-(varImp(fit.rf.rye)) #identify variable importance
plot(rye.varIMP)
#write.csv(rye.varIMP$importance, file = "Models/rye_varIMP.csv")
# Model Performance
predictions <- predict(fit.rf.rye, validation) #predict 
pred.error<-RMSE(predictions,validation$rye_HgHa) #get the Root Mean Standard Error of predicted values
exp(pred.error) #put in yield values

modelerror <- exp(predict(fit.rf.rye, rf )-1) #predict on whole dataset
head(modelerror) #make sure it worked honeyyyy
#write.csv(modelerror,file="Models/Predictions/rye_predictions.csv") # export for mapping

```

### Sorghum RFR
```{r, Analysis: Random Forest Trial, cache=TRUE}

rf.Sorghum<-read.csv(file="Models/Sorghum_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.Sorghum)
rf<-log10(rf+1)
summary(rf)
sapply(rf.Sorghum, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$Yield, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.Sorghum <- train(Yield~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.Sorghum) #print results
#write.csv(fit.rf.Sorghum$results, "Models/sorghum_rfFIT.csv")

stopCluster(cl)

sorghum.varIMP<-(varImp(fit.rf.Sorghum)) #identify variable importance
plot(sorghum.varIMP)
#write.csv(sorghum.varIMP$importance, file = "Models/Sorghum_varIMP.csv")
# Model Performance
predictions <- predict(fit.rf.Sorghum, validation) #predict 
pred.error<-RMSE(predictions,validation$Yield) #get the Root Mean Standard Error of predicted values
exp(pred.error) #put in yield values

modelerror <- exp(predict(fit.rf.Sorghum, rf )-1) #predict on whole dataset
head(modelerror) #make sure it worked honeyyyy
#write.csv(modelerror,file="Models/Predictions/Sorghum_predictions.csv") # export for mapping

```

### Soybean RFR
```{r, Analysis: Soybean RFR, cache=TRUE}

rf.Soybean<-read.csv(file="Models/Soybean_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.Soybean)
rf<-log10(rf+1)
summary(rf)
sapply(rf.Soybean, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$soybean_HgHa, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.Soybean <- train(soybean_HgHa~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.Soybean) #print results
#write.csv(fit.rf.Soybean$results, "Models/soybean_rfFIT.csv")


stopCluster(cl)

soybean.varIMP<-(varImp(fit.rf.Soybean)) #identify variable importance
plot(soybean.varIMP)
#write.csv(soybean.varIMP$importance, file = "Models/Soybean_varIMP.csv")
# Model Performance
predictions <- predict(fit.rf.Soybean, validation) #predict 
pred.error<-RMSE(predictions,validation$soybean_HgHa) #get the Root Mean Standard Error of predicted values
exp(pred.error) #put in yield values

modelerror <- exp(predict(fit.rf.Soybean, rf )-1) #predict on whole dataset
head(modelerror) #make sure it worked honeyyyy
#write.csv(modelerror,file="Models/Predictions/Soybean_predictions.csv") # export for mapping

```

### Sunflower RFR
```{r, Analysis: Sunflower RFR, cache=TRUE}

rf.Sunflower<-read.csv(file="Models/Sunflower_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.Sunflower)
rf<-log10(rf+1)
summary(rf)
sapply(rf.Sunflower, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$sunflower_HgHa, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.Sunflower <- train(sunflower_HgHa~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.Sunflower) #print results
#write.csv(fit.rf.Sunflower$results, "Models/sunflower_rfFIT.csv")

stopCluster(cl)

sunflower.varIMP<-(varImp(fit.rf.Sunflower)) #identify variable importance
plot(sunflower.varIMP)
#write.csv(sunflower.varIMP$importance, file = "Models/sunflower_varIMP.csv")
# Model Performance
predictions <- predict(fit.rf.Sunflower, validation) #predict 
pred.error<-RMSE(predictions,validation$sunflower_HgHa) #get the Root Mean Standard Error of predicted values
exp(pred.error) #put in yield values

modelerror <- exp(predict(fit.rf.Sunflower, rf )-1) #predict on whole dataset
head(modelerror) #make sure it worked honeyyyy
#write.csv(modelerror,file="Models/Predictions/Sunflower_predictions.csv") # export for mapping

```

### Wheat RFR
```{r, Analysis: Wheat RFR, cache=TRUE}

rf.Wheat<-read.csv(file="Models/Wheat_RF.csv", header = T, row.names = 1)
rf<-na.omit(rf.Wheat)
rf<-log10(rf+1)
summary(rf)
sapply(rf.Wheat, "class")

# create a list of 60% of the rows in the original dataset we can use for training
validation_index <- createDataPartition(rf$wheat_HgHa, p=0.60, list=FALSE)
# select 20% of the data for validation
validation <- rf[-validation_index,]
# use the remaining 60% of data to training and testing the models
dataset <- rf[validation_index,]     
# Run algorithms using 10-fold cross validation
control <- trainControl(method="repeatedcv", repeats = 10)  
metric <- "RMSE" 

# set up clusters

library(doParallel)
cl <- makePSOCKcluster(max(1,detectCores()-5))
registerDoParallel(cl)

# Random Forest
set.seed(7)
fit.rf.Wheat <- train(wheat_HgHa~., data=dataset, method="rf", metric=metric, trControl=control) #remove # to run again
print(fit.rf.Wheat) #print results
#write.csv(fit.rf.Wheat$results, "Models/wheat_rfFIT.csv")


stopCluster(cl)

wheat.varIMP<-(varImp(fit.rf.Wheat)) #identify variable importance
plot(wheat.varIMP)
#write.csv(wheat.varIMP$importance, file = "Models/wheat_varIMP.csv")
# Model Performance
predictions <- predict(fit.rf.Wheat, validation) #predict 
pred.error<-RMSE(predictions,validation$wheat_HgHa) #get the Root Mean Standard Error of predicted values
exp(pred.error) #put in yield values

modelerror <- exp(predict(fit.rf.Wheat, rf )-1) #predict on whole dataset
head(modelerror) #make sure it worked honeyyyy
#write.csv(modelerror,file="Models/Predictions/Wheat_predictions.csv") # export for mapping

```

## Variable Direction Estimation

<div class = "col-md-4">
<br><br> **What Was Tested:** How do crop yields increase or decrease with each single explantory variable in the RFR models? 
</div>

<div class = "col-md-4">
<br><br> **What This Allows Me To Do:** Identify how the emergent correlations from RFR are driven by individual variables. 
</div>

<div class = "col-md-4">
<br><br> **What Are The Model Assumptions:** Permutational Spearman rank-order correlations are used as they will identify monotonic relationships.Permutational tests were chosen as they have few assumptions about the distribution and independence of the data (i.e. exchangability is th only assumption however there is no way to test for this as we do not know the true distribution). Likewise permutational tests destroy the spatial-autocorrelation structure that influences test results. Plots are solely visual.
</div>


```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
## Barley
rf.barley<-read.csv(file="Models/Barley_RF.csv", header = T, row.names = 1)
rf.barley<-na.omit(rf.barley)
rf.barley<-log10(rf.barley+1)

#AET
barley.aet<-perm.relation(rf.barley$barley_HgHa,rf.barley$AET_mean,method = "pearson") 
#print(barley.aet)

#GDP
barley.gdp<-perm.relation(rf.barley$barley_HgHa,rf.barley$GDP_Mean,method = "pearson") 
#print(barley.gdp)

#Pest
barley.pest<-perm.relation(rf.barley$barley_HgHa,rf.barley$Pesticide,method = "pearson") 
#print(barley.pest)

#Fertilizer
barley.fert<-perm.relation(rf.barley$barley_HgHa,rf.barley$Barley_Fertilizer,method = "pearson") #print(barley.fert)
```

```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
##Cassava
rf.cassava<-read.csv(file="Models/Cassava_RF.csv", header = T, row.names = 1)
rf.cassava$Growing_Mean<-as.numeric(rf.cassava$Growing_Mean)
rf.cassava<-na.omit(rf.cassava)
rf.cassava<-log10(rf.cassava+1)

#AET
cassava.aet<-perm.relation(rf.cassava$cassava_HgHa,rf.cassava$AET_mean,method = "pearson") 
#print(cassava.aet)

#GDP
cassava.gdp<-perm.relation(rf.cassava$cassava_HgHa,rf.cassava$GDP_Mean,method = "pearson") 
#print(cassava.gdp)

#Pest
cassava.pest<-perm.relation(rf.cassava$cassava_HgHa,rf.cassava$Pesticide,method = "pearson") 
#print(cassava.pest)

#Fertilizer
cassava.fert<-perm.relation(rf.cassava$cassava_HgHa,rf.cassava$cassava_Fertilizer,method = "pearson")
#print(cassava.fert)

```


```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
##Groundnut
rf.groundnut<-read.csv(file="Models/Groundnut_RF.csv", header = T, row.names = 1)
rf.groundnut$Growing_Mean<-as.numeric(rf.groundnut$Growing_Mean)
rf.groundnut<-na.omit(rf.groundnut)
rf.groundnut<-log10(rf.groundnut+1)

#AET
groundnut.aet<-perm.relation(rf.groundnut$groundnut_HgHa,rf.groundnut$AET_mean,method = "pearson") 
#print(groundnut.aet)

#GDP
groundnut.gdp<-perm.relation(rf.groundnut$groundnut_HgHa,rf.groundnut$GDP_Mean,method = "pearson") 
#print(groundnut.gdp)

#Pest
groundnut.pest<-perm.relation(rf.groundnut$groundnut_HgHa,rf.groundnut$Pesticide,method = "pearson") 
#print(groundnut.pest)

#Fertilizer
groundnut.fert<-perm.relation(rf.groundnut$groundnut_HgHa,rf.groundnut$groundnut_Fertilizer,method = "pearson")
#print(groundnut.fert)


```

```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
##Maize
rf.maize<-read.csv(file="Models/Maize_RF.csv", header = T, row.names = 1)
rf.maize$Growing_Mean<-as.numeric(rf.maize$Growing_Mean)
rf.maize<-na.omit(rf.maize)
rf.maize<-log10(rf.maize+1)

#AET
maize.aet<-perm.relation(rf.maize$maize_HgHa,rf.maize$AET_mean,method = "pearson") 
#print(maize.aet)

#GDP
maize.gdp<-perm.relation(rf.maize$maize_HgHa,rf.maize$GDP_Mean,method = "pearson") 
#print(maize.gdp)

#Pest
maize.pest<-perm.relation(rf.maize$maize_HgHa,rf.maize$Pesticide,method = "pearson") 
#print(maize.pest)

#Fertilizer
maize.fert<-perm.relation(rf.maize$maize_HgHa,rf.maize$maize_Fertilizer,method = "pearson")
#print(maize.fert)

```

```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
##Millet

rf.millet<-read.csv(file="Models/Millet_RF.csv", header = T, row.names = 1)
rf.millet$Growing_Mean<-as.numeric(rf.millet$Growing_Mean)
rf.millet<-na.omit(rf.millet)
rf.millet<-log10(rf.millet+1)

#AET
millet.aet<-perm.relation(rf.millet$millet_HgHa,rf.millet$AET_mean,method = "pearson") 
#print(millet.aet)

#GDP
millet.gdp<-perm.relation(rf.millet$millet_HgHa,rf.millet$GDP_Mean,method = "pearson") 
#print(millet.gdp)

#Pest
millet.pest<-perm.relation(rf.millet$millet_HgHa,rf.millet$Pesticide,method = "pearson") 
#print(millet.pest)

#Fertilizer
millet.fert<-perm.relation(rf.millet$millet_HgHa,rf.millet$millet_Fertilizer,method = "pearson")
#print(millet.fert)
```

```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
##Rapeseed
rf.rapeseed<-read.csv(file="Models/Rapeseed_RF.csv", header = T, row.names = 1)
rf.rapeseed<-na.omit(rf.rapeseed)
rf.rapeseed<-log10(rf.rapeseed+1)

#AET
rapeseed.aet<-perm.relation(rf.rapeseed$rapeseed_HgHa,rf.rapeseed$AET_mean,method = "pearson") 
#print(rapeseed.aet)

#GDP
rapeseed.gdp<-perm.relation(rf.rapeseed$rapeseed_HgHa,rf.rapeseed$GDP_Mean,method = "pearson") 
#print(rapeseed.gdp)

#Pest
rapeseed.pest<-perm.relation(rf.rapeseed$rapeseed_HgHa,rf.rapeseed$Pesticide,method = "pearson") 
#print(rapeseed.pest)

#Fertilizer
rapeseed.fert<-perm.relation(rf.rapeseed$rapeseed_HgHa,rf.rapeseed$rapeseed_Fertilizer,method = "pearson")
#print(rapeseed.fert)

```

```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
##Rice
rf.rice<-read.csv(file="Models/Rice_RF.csv", header = T, row.names = 1)
rf.rice<-na.omit(rf.rice)
rf.rice<-log10(rf.rice+1)

#AET
rice.aet<-perm.relation(rf.rice$rice_HgHa,rf.rice$AET_mean,method = "pearson") 
#print(rice.aet)

#GDP
rice.gdp<-perm.relation(rf.rice$rice_HgHa,rf.rice$GDP_Mean,method = "pearson") 
#print(rice.gdp)

#Pest
rice.pest<-perm.relation(rf.rice$rice_HgHa,rf.rice$Pesticide,method = "pearson") 
#print(rice.pest)

#Fertilizer
rice.fert<-perm.relation(rf.rice$rice_HgHa,rf.rice$rice_Fertilizer,method = "pearson")
#print(rice.fert)

```

```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
##Rye
rf.rye<-read.csv(file="Models/Rye_RF.csv", header = T, row.names = 1)
rf.rye<-na.omit(rf.rye)
rf.rye<-log10(rf.rye+1)

#AET
rye.aet<-perm.relation(rf.rye$rye_HgHa,rf.rye$AET_mean,method = "pearson") 
#print(rye.aet)

#GDP
rye.gdp<-perm.relation(rf.rye$rye_HgHa,rf.rye$GDP_Mean,method = "pearson") 
#print(rye.gdp)

#Pest
rye.pest<-perm.relation(rf.rye$rye_HgHa,rf.rye$Pesticide,method = "pearson") 
#print(rye.pest)

#Fertilizer
rye.fert<-perm.relation(rf.rye$rye_HgHa,rf.rye$rye_Fertilizer,method = "pearson")
#print(rye.fert)
```

```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
##Sorghum
rf.sorghum<-read.csv(file="Models/Sorghum_RF.csv", header = T, row.names = 1)
rf.sorghum<-na.omit(rf.sorghum)
rf.sorghum<-log10(rf.sorghum+1)

#AET
sorghum.aet<-perm.relation(rf.sorghum$Yield,rf.sorghum$Evapotranspiraton,method = "pearson") 
#print(sorghum.aet)

#GDP
sorghum.gdp<-perm.relation(rf.sorghum$Yield,rf.sorghum$GDP,method = "pearson") 
#print(sorghum.gdp)

#Pest
sorghum.pest<-perm.relation(rf.sorghum$Yield,rf.sorghum$Pesticide,method = "pearson") 
#print(sorghum.pest)

#Fertilizer
sorghum.fert<-perm.relation(rf.sorghum$Yield,rf.sorghum$sorghum_Fertilizer,method = "pearson")
#print(sorghum.fert)
```

```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
##Soybean
rf.soybean<-read.csv(file="Models/Soybean_RF.csv", header = T, row.names = 1)
rf.soybean<-na.omit(rf.soybean)
rf.soybean<-log10(rf.soybean+1)

#AET
soybean.aet<-perm.relation(rf.soybean$soybean_HgHa,rf.soybean$AET_mean,method = "pearson") 
#print(soybean.aet)

#GDP
soybean.gdp<-perm.relation(rf.soybean$soybean_HgHa,rf.soybean$GDP_Mean,method = "pearson") 
#print(soybean.gdp)

#Pest
soybean.pest<-perm.relation(rf.soybean$soybean_HgHa,rf.soybean$Pesticide,method = "pearson") 
#print(soybean.pest)

#Fertilizer
soybean.fert<-perm.relation(rf.soybean$soybean_HgHa,rf.soybean$soybean_Fertilizer,method = "pearson")
#print(soybean.fert)
```

```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
##Sunflower
rf.sunflower<-read.csv(file="Models/Sunflower_RF.csv", header = T, row.names = 1)
rf.sunflower<-na.omit(rf.sunflower)
rf.sunflower<-log10(rf.sunflower+1)

#AET
sunflower.aet<-perm.relation(rf.sunflower$sunflower_HgHa,rf.sunflower$AET_mean,method = "pearson") 
#print(sunflower.aet)

#GDP
sunflower.gdp<-perm.relation(rf.sunflower$sunflower_HgHa,rf.sunflower$GDP_Mean,method = "pearson")
#print(sunflower.gdp)

#Pest
sunflower.pest<-perm.relation(rf.sunflower$sunflower_HgHa,rf.sunflower$Pesticide,method = "pearson") 
#print(sunflower.pest)

#Fertilizer
sunflower.fert<-perm.relation(rf.sunflower$sunflower_HgHa,rf.sunflower$sunflower_Fertilizer,method = "pearson")
#print(sunflower.fert)
```

```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE}
##Wheat
rf.wheat<-read.csv(file="Models/Wheat_RF.csv", header = T, row.names = 1)
rf.wheat<-na.omit(rf.wheat)
rf.wheat<-log10(rf.wheat+1)

#AET
wheat.aet<-perm.relation(rf.wheat$wheat_HgHa,rf.wheat$AET_mean,method = "pearson") 
#print(wheat.aet)

#GDP
wheat.gdp<-perm.relation(rf.wheat$wheat_HgHa,rf.wheat$GDP_Mean,method = "pearson") 
#print(wheat.gdp)

#Pest
wheat.pest<-perm.relation(rf.wheat$wheat_HgHa,rf.wheat$Pesticide,method = "pearson")
#print(wheat.pest)

#Fertilizer
wheat.fert<-perm.relation(rf.wheat$wheat_HgHa,rf.wheat$wheat_Fertilizer,method = "pearson")
#print(wheat.fert)
```

#Variable Direction Heatmap
```{r,fig.align='center',message=FALSE, warning=FALSE, cache=TRUE, fig.cap="Heatmap of R2 coefficients for each variable by crop"}

vard<-read.csv(file="Models/VariableDirection/VariableDirection.csv", header=T)


#values
vard$Crop<-factor(vard$Crop, levels=vard$Crop) #set factor
vard.m<-melt(vard) #melt

#heatmap
ggplot(vard.m, aes(x=vard.m$Crop, y=vard.m$variable, fill=vard.m$value)) +geom_tile() + theme_bw() +theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    panel.background = element_blank()) + 
  ylab("Crop") +xlab("Variable") + labs(color='Rho') +scale_fill_gradient(low="white", high="#1B3C7C") +theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


```


ggplot(groundnut, aes(x=Groundnut_Error_Ratio))+geom_density(size=0.9, color="#004F86")+geom_vline(xintercept = 1,size=1.5, color="#CE271D") +theme_bw() +theme(axis.line = element_line(colour = "black"),panel.grid.major = element_blank(),panel.grid.minor = element_blank(),panel.border = element_blank(),panel.background = element_blank()) +xlab("Model Error") +ylab ("Kernal Density")

